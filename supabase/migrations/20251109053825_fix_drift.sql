drop extension if exists "pg_net";

create sequence "public"."explanationMetrics_id_seq";

create sequence "public"."explanation_tags_id_seq";

create sequence "public"."llm_call_tracking_id_seq";

create sequence "public"."tags_id_seq";

create sequence "public"."testing_edits_pipeline_id_seq";

create sequence "public"."userQueries_id_seq";

create sequence "public"."user_library_id_seq";

create sequence "public"."userexplanationevents_id_seq";


  create table "public"."explanationMetrics" (
    "id" integer not null default nextval('public."explanationMetrics_id_seq"'::regclass),
    "explanationid" integer not null,
    "total_saves" integer not null default 0,
    "total_views" integer not null default 0,
    "save_rate" numeric(5,4) not null default 0.0000,
    "last_updated" timestamp with time zone not null default now()
      );



  create table "public"."explanation_tags" (
    "id" integer not null default nextval('public.explanation_tags_id_seq'::regclass),
    "explanation_id" integer not null,
    "tag_id" integer not null,
    "created_at" timestamp with time zone default now(),
    "isDeleted" boolean not null default false
      );



  create table "public"."explanations" (
    "id" bigint generated by default as identity not null,
    "explanation_title" text not null,
    "content" text not null,
    "timestamp" timestamp without time zone not null default now(),
    "primary_topic_id" bigint not null,
    "secondary_topic_id" bigint,
    "status" character varying(20) not null default 'published'::character varying
      );



  create table "public"."llmCallTracking" (
    "id" integer not null default nextval('public.llm_call_tracking_id_seq'::regclass),
    "prompt" text not null,
    "call_source" character varying(255) not null,
    "content" text not null,
    "raw_api_response" text not null,
    "model" character varying(100),
    "prompt_tokens" integer,
    "completion_tokens" integer,
    "total_tokens" integer,
    "reasoning_tokens" integer,
    "finish_reason" character varying(50),
    "created_at" timestamp with time zone default CURRENT_TIMESTAMP,
    "userid" uuid not null
      );



  create table "public"."tags" (
    "id" integer not null default nextval('public.tags_id_seq'::regclass),
    "tag_name" character varying(255) not null,
    "tag_description" text not null,
    "created_at" timestamp with time zone default now(),
    "presetTagId" integer
      );



  create table "public"."testing_edits_pipeline" (
    "id" integer not null default nextval('public.testing_edits_pipeline_id_seq'::regclass),
    "set_name" character varying(255) not null,
    "step" character varying(255) not null,
    "content" text not null,
    "session_id" uuid,
    "explanation_id" integer,
    "explanation_title" text,
    "user_prompt" text,
    "source_content" text,
    "session_metadata" jsonb,
    "created_at" timestamp with time zone default CURRENT_TIMESTAMP,
    "updated_at" timestamp with time zone default CURRENT_TIMESTAMP
      );



  create table "public"."topics" (
    "id" bigint generated by default as identity not null,
    "topic_title" text not null,
    "topic_description" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."topics" enable row level security;


  create table "public"."userExplanationEvents" (
    "id" integer not null default nextval('public.userexplanationevents_id_seq'::regclass),
    "userid" uuid not null,
    "event_name" text not null,
    "explanationid" integer not null,
    "value" integer not null,
    "metadata" text not null
      );



  create table "public"."userLibrary" (
    "id" integer not null default nextval('public.user_library_id_seq'::regclass),
    "explanationid" bigint not null,
    "userid" uuid not null,
    "created" timestamp without time zone not null default CURRENT_TIMESTAMP
      );


alter table "public"."userLibrary" enable row level security;


  create table "public"."userQueries" (
    "id" bigint not null default nextval('public."userQueries_id_seq"'::regclass),
    "timestamp" timestamp with time zone not null default now(),
    "user_query" text not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "matches" jsonb not null default '[]'::jsonb,
    "explanation_id" integer,
    "userid" uuid not null,
    "newExplanation" boolean not null,
    "userInputType" text,
    "allowedQuery" boolean,
    "previousExplanationViewedId" bigint
      );


alter table "public"."userQueries" enable row level security;

alter sequence "public"."explanationMetrics_id_seq" owned by "public"."explanationMetrics"."id";

alter sequence "public"."explanation_tags_id_seq" owned by "public"."explanation_tags"."id";

alter sequence "public"."llm_call_tracking_id_seq" owned by "public"."llmCallTracking"."id";

alter sequence "public"."tags_id_seq" owned by "public"."tags"."id";

alter sequence "public"."testing_edits_pipeline_id_seq" owned by "public"."testing_edits_pipeline"."id";

alter sequence "public"."userQueries_id_seq" owned by "public"."userQueries"."id";

alter sequence "public"."user_library_id_seq" owned by "public"."userLibrary"."id";

alter sequence "public"."userexplanationevents_id_seq" owned by "public"."userExplanationEvents"."id";

CREATE UNIQUE INDEX "explanationMetrics_pkey" ON public."explanationMetrics" USING btree (id);

CREATE UNIQUE INDEX explanation_tags_pkey ON public.explanation_tags USING btree (id);

CREATE INDEX explanationmetrics_explanationid_idx ON public."explanationMetrics" USING btree (explanationid);

CREATE UNIQUE INDEX explanationmetrics_explanationid_unique ON public."explanationMetrics" USING btree (explanationid);

CREATE INDEX explanationmetrics_last_updated_idx ON public."explanationMetrics" USING btree (last_updated);

CREATE INDEX idx_explanation_tags_explanation_isdeleted ON public.explanation_tags USING btree (explanation_id, "isDeleted");

CREATE INDEX idx_explanation_tags_isdeleted ON public.explanation_tags USING btree ("isDeleted");

CREATE INDEX idx_explanation_tags_tag_isdeleted ON public.explanation_tags USING btree (tag_id, "isDeleted");

CREATE INDEX idx_explanations_status ON public.explanations USING btree (status);

CREATE UNIQUE INDEX llm_call_tracking_pkey ON public."llmCallTracking" USING btree (id);

CREATE UNIQUE INDEX searches_pkey ON public.explanations USING btree (id);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

CREATE UNIQUE INDEX tags_tag_name_key ON public.tags USING btree (tag_name);

CREATE UNIQUE INDEX testing_edits_pipeline_pkey ON public.testing_edits_pipeline USING btree (id);

CREATE UNIQUE INDEX topics_pkey ON public.topics USING btree (id);

CREATE INDEX topics_title_idx ON public.topics USING btree (topic_title);

CREATE UNIQUE INDEX topics_topic_title_unique ON public.topics USING btree (topic_title);

CREATE UNIQUE INDEX "userQueries_id_key" ON public."userQueries" USING btree (id);

CREATE UNIQUE INDEX "userQueries_pkey" ON public."userQueries" USING btree (id);

CREATE UNIQUE INDEX user_library_pkey ON public."userLibrary" USING btree (id);

CREATE UNIQUE INDEX userexplanationevents_pkey ON public."userExplanationEvents" USING btree (id);

alter table "public"."explanationMetrics" add constraint "explanationMetrics_pkey" PRIMARY KEY using index "explanationMetrics_pkey";

alter table "public"."explanation_tags" add constraint "explanation_tags_pkey" PRIMARY KEY using index "explanation_tags_pkey";

alter table "public"."explanations" add constraint "searches_pkey" PRIMARY KEY using index "searches_pkey";

alter table "public"."llmCallTracking" add constraint "llm_call_tracking_pkey" PRIMARY KEY using index "llm_call_tracking_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."testing_edits_pipeline" add constraint "testing_edits_pipeline_pkey" PRIMARY KEY using index "testing_edits_pipeline_pkey";

alter table "public"."topics" add constraint "topics_pkey" PRIMARY KEY using index "topics_pkey";

alter table "public"."userExplanationEvents" add constraint "userexplanationevents_pkey" PRIMARY KEY using index "userexplanationevents_pkey";

alter table "public"."userLibrary" add constraint "user_library_pkey" PRIMARY KEY using index "user_library_pkey";

alter table "public"."userQueries" add constraint "userQueries_pkey" PRIMARY KEY using index "userQueries_pkey";

alter table "public"."explanationMetrics" add constraint "explanationmetrics_explanationid_unique" UNIQUE using index "explanationmetrics_explanationid_unique";

alter table "public"."explanationMetrics" add constraint "explanationmetrics_save_rate_check" CHECK (((save_rate >= 0.0) AND (save_rate <= 1.0))) not valid;

alter table "public"."explanationMetrics" validate constraint "explanationmetrics_save_rate_check";

alter table "public"."explanationMetrics" add constraint "explanationmetrics_total_saves_check" CHECK ((total_saves >= 0)) not valid;

alter table "public"."explanationMetrics" validate constraint "explanationmetrics_total_saves_check";

alter table "public"."explanationMetrics" add constraint "explanationmetrics_total_views_check" CHECK ((total_views >= 0)) not valid;

alter table "public"."explanationMetrics" validate constraint "explanationmetrics_total_views_check";

alter table "public"."explanation_tags" add constraint "fk_explanation_tags_tag_id" FOREIGN KEY (tag_id) REFERENCES public.tags(id) not valid;

alter table "public"."explanation_tags" validate constraint "fk_explanation_tags_tag_id";

alter table "public"."explanations" add constraint "chk_explanation_status" CHECK (((status)::text = ANY ((ARRAY['draft'::character varying, 'published'::character varying])::text[]))) not valid;

alter table "public"."explanations" validate constraint "chk_explanation_status";

alter table "public"."explanations" add constraint "fk_primary_topic" FOREIGN KEY (primary_topic_id) REFERENCES public.topics(id) ON DELETE RESTRICT not valid;

alter table "public"."explanations" validate constraint "fk_primary_topic";

alter table "public"."explanations" add constraint "fk_secondary_topic" FOREIGN KEY (secondary_topic_id) REFERENCES public.topics(id) ON DELETE SET NULL not valid;

alter table "public"."explanations" validate constraint "fk_secondary_topic";

alter table "public"."llmCallTracking" add constraint "llm_call_tracking_completion_tokens_check" CHECK ((completion_tokens >= 0)) not valid;

alter table "public"."llmCallTracking" validate constraint "llm_call_tracking_completion_tokens_check";

alter table "public"."llmCallTracking" add constraint "llm_call_tracking_prompt_tokens_check" CHECK ((prompt_tokens >= 0)) not valid;

alter table "public"."llmCallTracking" validate constraint "llm_call_tracking_prompt_tokens_check";

alter table "public"."llmCallTracking" add constraint "llm_call_tracking_reasoning_tokens_check" CHECK ((reasoning_tokens >= 0)) not valid;

alter table "public"."llmCallTracking" validate constraint "llm_call_tracking_reasoning_tokens_check";

alter table "public"."llmCallTracking" add constraint "llm_call_tracking_total_tokens_check" CHECK ((total_tokens >= 0)) not valid;

alter table "public"."llmCallTracking" validate constraint "llm_call_tracking_total_tokens_check";

alter table "public"."tags" add constraint "tags_tag_name_key" UNIQUE using index "tags_tag_name_key";

alter table "public"."testing_edits_pipeline" add constraint "testing_edits_pipeline_content_check" CHECK ((content <> ''::text)) not valid;

alter table "public"."testing_edits_pipeline" validate constraint "testing_edits_pipeline_content_check";

alter table "public"."testing_edits_pipeline" add constraint "testing_edits_pipeline_set_name_check" CHECK (((set_name)::text <> ''::text)) not valid;

alter table "public"."testing_edits_pipeline" validate constraint "testing_edits_pipeline_set_name_check";

alter table "public"."testing_edits_pipeline" add constraint "testing_edits_pipeline_step_check" CHECK (((step)::text <> ''::text)) not valid;

alter table "public"."testing_edits_pipeline" validate constraint "testing_edits_pipeline_step_check";

alter table "public"."topics" add constraint "topics_topic_title_unique" UNIQUE using index "topics_topic_title_unique";

alter table "public"."userLibrary" add constraint "userLibrary_explanationid_fkey" FOREIGN KEY (explanationid) REFERENCES public.explanations(id) not valid;

alter table "public"."userLibrary" validate constraint "userLibrary_explanationid_fkey";

alter table "public"."userQueries" add constraint "userQueries_explanation_id_fkey" FOREIGN KEY (explanation_id) REFERENCES public.explanations(id) not valid;

alter table "public"."userQueries" validate constraint "userQueries_explanation_id_fkey";

alter table "public"."userQueries" add constraint "userQueries_id_key" UNIQUE using index "userQueries_id_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.increment_explanation_saves(p_explanation_id integer)
 RETURNS TABLE(id integer, explanation_id integer, total_saves integer, total_views integer, save_rate numeric, last_updated timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Simply increment existing save count by 1 and recalculate save rate
    INSERT INTO "explanationMetrics" (explanationid, total_saves, total_views, save_rate, last_updated)
    VALUES (p_explanation_id, 1, 0, 0.0000, NOW())
    ON CONFLICT (explanationid) 
    DO UPDATE SET
        total_saves = "explanationMetrics".total_saves + 1,
        save_rate = CASE 
            WHEN "explanationMetrics".total_views > 0 THEN 
                ROUND((("explanationMetrics".total_saves + 1)::DECIMAL / "explanationMetrics".total_views::DECIMAL), 4)
            ELSE 0.0000
        END,
        last_updated = NOW();
    
    -- Return the updated record
    RETURN QUERY
    SELECT m.id, m.explanationid AS explanation_id, m.total_saves, m.total_views, m.save_rate, m.last_updated
    FROM "explanationMetrics" m
    WHERE m.explanationid = p_explanation_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.increment_explanation_views(p_explanation_id integer)
 RETURNS TABLE(id integer, explanation_id integer, total_saves integer, total_views integer, save_rate numeric, last_updated timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Simply increment existing view count by 1 and recalculate save rate
    INSERT INTO "explanationMetrics" (explanationid, total_saves, total_views, save_rate, last_updated)
    VALUES (p_explanation_id, 0, 1, 0.0000, NOW())
    ON CONFLICT (explanationid) 
    DO UPDATE SET
        total_views = "explanationMetrics".total_views + 1,
        save_rate = CASE 
            WHEN "explanationMetrics".total_views + 1 > 0 THEN 
                ROUND(("explanationMetrics".total_saves::DECIMAL / ("explanationMetrics".total_views + 1)::DECIMAL), 4)
            ELSE 0.0000
        END,
        last_updated = NOW();
    
    -- Return the updated record
    RETURN QUERY
    SELECT m.id, m.explanationid AS explanation_id, m.total_saves, m.total_views, m.save_rate, m.last_updated
    FROM "explanationMetrics" m
    WHERE m.explanationid = p_explanation_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.refresh_all_explanation_metrics()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    all_explanation_ids INTEGER[];
    processed_count INTEGER := 0;
BEGIN
    -- Get all unique explanation IDs from both tables
    SELECT ARRAY(
        SELECT DISTINCT explanationid 
        FROM (
            SELECT explanationid FROM "userLibrary"
            UNION
            SELECT explanationid FROM "userExplanationEvents"
            WHERE event_name = 'explanation_viewed'
        ) AS all_explanations
        ORDER BY explanationid
    ) INTO all_explanation_ids;
    
    -- If no explanations found, return 0
    IF all_explanation_ids IS NULL OR array_length(all_explanation_ids, 1) IS NULL THEN
        RETURN 0;
    END IF;
    
    -- Refresh metrics for all explanations in one batch operation
    PERFORM refresh_explanation_metrics(all_explanation_ids);
    
    -- Return count of processed explanations
    processed_count := array_length(all_explanation_ids, 1);
    RETURN processed_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.refresh_explanation_metrics(explanation_ids integer[])
 RETURNS TABLE(id integer, explanationid integer, total_saves integer, total_views integer, save_rate numeric, last_updated timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Batch calculate and upsert metrics for all explanation IDs
    INSERT INTO "explanationMetrics" (explanationid, total_saves, total_views, save_rate, last_updated)
    SELECT 
        exp_id,
        COALESCE(saves.save_count, 0) as total_saves,
        COALESCE(views.view_count, 0) as total_views,
        CASE 
            WHEN COALESCE(views.view_count, 0) > 0 THEN 
                ROUND((COALESCE(saves.save_count, 0)::DECIMAL / views.view_count::DECIMAL), 4)
            ELSE 0.0000
        END as save_rate,
        NOW() as last_updated
    FROM unnest(explanation_ids) AS exp_id
    LEFT JOIN (
        -- Calculate saves for each explanation
        SELECT explanationid, COUNT(*) as save_count
        FROM "userLibrary"
        WHERE explanationid = ANY(explanation_ids)
        GROUP BY explanationid
    ) saves ON exp_id = saves.explanationid
    LEFT JOIN (
        -- Calculate views for each explanation  
        SELECT explanationid, SUM(value) as view_count
        FROM "userExplanationEvents"
        WHERE explanationid = ANY(explanation_ids)
        AND event_name = 'explanation_viewed'
        GROUP BY explanationid
    ) views ON exp_id = views.explanationid
    ON CONFLICT (explanationid) 
    DO UPDATE SET
        total_saves = EXCLUDED.total_saves,
        total_views = EXCLUDED.total_views,
        save_rate = EXCLUDED.save_rate,
        last_updated = EXCLUDED.last_updated;
    
    -- Return all updated records
    RETURN QUERY
    SELECT m.id, m.explanationid, m.total_saves, m.total_views, m.save_rate, m.last_updated
    FROM "explanationMetrics" m
    WHERE m.explanationid = ANY(explanation_ids)
    ORDER BY m.explanationid;
END;
$function$
;

grant delete on table "public"."explanationMetrics" to "anon";

grant insert on table "public"."explanationMetrics" to "anon";

grant references on table "public"."explanationMetrics" to "anon";

grant select on table "public"."explanationMetrics" to "anon";

grant trigger on table "public"."explanationMetrics" to "anon";

grant truncate on table "public"."explanationMetrics" to "anon";

grant update on table "public"."explanationMetrics" to "anon";

grant delete on table "public"."explanationMetrics" to "authenticated";

grant insert on table "public"."explanationMetrics" to "authenticated";

grant references on table "public"."explanationMetrics" to "authenticated";

grant select on table "public"."explanationMetrics" to "authenticated";

grant trigger on table "public"."explanationMetrics" to "authenticated";

grant truncate on table "public"."explanationMetrics" to "authenticated";

grant update on table "public"."explanationMetrics" to "authenticated";

grant delete on table "public"."explanationMetrics" to "service_role";

grant insert on table "public"."explanationMetrics" to "service_role";

grant references on table "public"."explanationMetrics" to "service_role";

grant select on table "public"."explanationMetrics" to "service_role";

grant trigger on table "public"."explanationMetrics" to "service_role";

grant truncate on table "public"."explanationMetrics" to "service_role";

grant update on table "public"."explanationMetrics" to "service_role";

grant delete on table "public"."explanation_tags" to "anon";

grant insert on table "public"."explanation_tags" to "anon";

grant references on table "public"."explanation_tags" to "anon";

grant select on table "public"."explanation_tags" to "anon";

grant trigger on table "public"."explanation_tags" to "anon";

grant truncate on table "public"."explanation_tags" to "anon";

grant update on table "public"."explanation_tags" to "anon";

grant delete on table "public"."explanation_tags" to "authenticated";

grant insert on table "public"."explanation_tags" to "authenticated";

grant references on table "public"."explanation_tags" to "authenticated";

grant select on table "public"."explanation_tags" to "authenticated";

grant trigger on table "public"."explanation_tags" to "authenticated";

grant truncate on table "public"."explanation_tags" to "authenticated";

grant update on table "public"."explanation_tags" to "authenticated";

grant delete on table "public"."explanation_tags" to "service_role";

grant insert on table "public"."explanation_tags" to "service_role";

grant references on table "public"."explanation_tags" to "service_role";

grant select on table "public"."explanation_tags" to "service_role";

grant trigger on table "public"."explanation_tags" to "service_role";

grant truncate on table "public"."explanation_tags" to "service_role";

grant update on table "public"."explanation_tags" to "service_role";

grant delete on table "public"."explanations" to "anon";

grant insert on table "public"."explanations" to "anon";

grant references on table "public"."explanations" to "anon";

grant select on table "public"."explanations" to "anon";

grant trigger on table "public"."explanations" to "anon";

grant truncate on table "public"."explanations" to "anon";

grant update on table "public"."explanations" to "anon";

grant delete on table "public"."explanations" to "authenticated";

grant insert on table "public"."explanations" to "authenticated";

grant references on table "public"."explanations" to "authenticated";

grant select on table "public"."explanations" to "authenticated";

grant trigger on table "public"."explanations" to "authenticated";

grant truncate on table "public"."explanations" to "authenticated";

grant update on table "public"."explanations" to "authenticated";

grant delete on table "public"."explanations" to "service_role";

grant insert on table "public"."explanations" to "service_role";

grant references on table "public"."explanations" to "service_role";

grant select on table "public"."explanations" to "service_role";

grant trigger on table "public"."explanations" to "service_role";

grant truncate on table "public"."explanations" to "service_role";

grant update on table "public"."explanations" to "service_role";

grant delete on table "public"."llmCallTracking" to "anon";

grant insert on table "public"."llmCallTracking" to "anon";

grant references on table "public"."llmCallTracking" to "anon";

grant select on table "public"."llmCallTracking" to "anon";

grant trigger on table "public"."llmCallTracking" to "anon";

grant truncate on table "public"."llmCallTracking" to "anon";

grant update on table "public"."llmCallTracking" to "anon";

grant delete on table "public"."llmCallTracking" to "authenticated";

grant insert on table "public"."llmCallTracking" to "authenticated";

grant references on table "public"."llmCallTracking" to "authenticated";

grant select on table "public"."llmCallTracking" to "authenticated";

grant trigger on table "public"."llmCallTracking" to "authenticated";

grant truncate on table "public"."llmCallTracking" to "authenticated";

grant update on table "public"."llmCallTracking" to "authenticated";

grant delete on table "public"."llmCallTracking" to "service_role";

grant insert on table "public"."llmCallTracking" to "service_role";

grant references on table "public"."llmCallTracking" to "service_role";

grant select on table "public"."llmCallTracking" to "service_role";

grant trigger on table "public"."llmCallTracking" to "service_role";

grant truncate on table "public"."llmCallTracking" to "service_role";

grant update on table "public"."llmCallTracking" to "service_role";

grant delete on table "public"."tags" to "anon";

grant insert on table "public"."tags" to "anon";

grant references on table "public"."tags" to "anon";

grant select on table "public"."tags" to "anon";

grant trigger on table "public"."tags" to "anon";

grant truncate on table "public"."tags" to "anon";

grant update on table "public"."tags" to "anon";

grant delete on table "public"."tags" to "authenticated";

grant insert on table "public"."tags" to "authenticated";

grant references on table "public"."tags" to "authenticated";

grant select on table "public"."tags" to "authenticated";

grant trigger on table "public"."tags" to "authenticated";

grant truncate on table "public"."tags" to "authenticated";

grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";

grant insert on table "public"."tags" to "service_role";

grant references on table "public"."tags" to "service_role";

grant select on table "public"."tags" to "service_role";

grant trigger on table "public"."tags" to "service_role";

grant truncate on table "public"."tags" to "service_role";

grant update on table "public"."tags" to "service_role";

grant delete on table "public"."testing_edits_pipeline" to "anon";

grant insert on table "public"."testing_edits_pipeline" to "anon";

grant references on table "public"."testing_edits_pipeline" to "anon";

grant select on table "public"."testing_edits_pipeline" to "anon";

grant trigger on table "public"."testing_edits_pipeline" to "anon";

grant truncate on table "public"."testing_edits_pipeline" to "anon";

grant update on table "public"."testing_edits_pipeline" to "anon";

grant delete on table "public"."testing_edits_pipeline" to "authenticated";

grant insert on table "public"."testing_edits_pipeline" to "authenticated";

grant references on table "public"."testing_edits_pipeline" to "authenticated";

grant select on table "public"."testing_edits_pipeline" to "authenticated";

grant trigger on table "public"."testing_edits_pipeline" to "authenticated";

grant truncate on table "public"."testing_edits_pipeline" to "authenticated";

grant update on table "public"."testing_edits_pipeline" to "authenticated";

grant delete on table "public"."testing_edits_pipeline" to "service_role";

grant insert on table "public"."testing_edits_pipeline" to "service_role";

grant references on table "public"."testing_edits_pipeline" to "service_role";

grant select on table "public"."testing_edits_pipeline" to "service_role";

grant trigger on table "public"."testing_edits_pipeline" to "service_role";

grant truncate on table "public"."testing_edits_pipeline" to "service_role";

grant update on table "public"."testing_edits_pipeline" to "service_role";

grant delete on table "public"."topics" to "anon";

grant insert on table "public"."topics" to "anon";

grant references on table "public"."topics" to "anon";

grant select on table "public"."topics" to "anon";

grant trigger on table "public"."topics" to "anon";

grant truncate on table "public"."topics" to "anon";

grant update on table "public"."topics" to "anon";

grant delete on table "public"."topics" to "authenticated";

grant insert on table "public"."topics" to "authenticated";

grant references on table "public"."topics" to "authenticated";

grant select on table "public"."topics" to "authenticated";

grant trigger on table "public"."topics" to "authenticated";

grant truncate on table "public"."topics" to "authenticated";

grant update on table "public"."topics" to "authenticated";

grant delete on table "public"."topics" to "service_role";

grant insert on table "public"."topics" to "service_role";

grant references on table "public"."topics" to "service_role";

grant select on table "public"."topics" to "service_role";

grant trigger on table "public"."topics" to "service_role";

grant truncate on table "public"."topics" to "service_role";

grant update on table "public"."topics" to "service_role";

grant delete on table "public"."userExplanationEvents" to "anon";

grant insert on table "public"."userExplanationEvents" to "anon";

grant references on table "public"."userExplanationEvents" to "anon";

grant select on table "public"."userExplanationEvents" to "anon";

grant trigger on table "public"."userExplanationEvents" to "anon";

grant truncate on table "public"."userExplanationEvents" to "anon";

grant update on table "public"."userExplanationEvents" to "anon";

grant delete on table "public"."userExplanationEvents" to "authenticated";

grant insert on table "public"."userExplanationEvents" to "authenticated";

grant references on table "public"."userExplanationEvents" to "authenticated";

grant select on table "public"."userExplanationEvents" to "authenticated";

grant trigger on table "public"."userExplanationEvents" to "authenticated";

grant truncate on table "public"."userExplanationEvents" to "authenticated";

grant update on table "public"."userExplanationEvents" to "authenticated";

grant delete on table "public"."userExplanationEvents" to "service_role";

grant insert on table "public"."userExplanationEvents" to "service_role";

grant references on table "public"."userExplanationEvents" to "service_role";

grant select on table "public"."userExplanationEvents" to "service_role";

grant trigger on table "public"."userExplanationEvents" to "service_role";

grant truncate on table "public"."userExplanationEvents" to "service_role";

grant update on table "public"."userExplanationEvents" to "service_role";

grant delete on table "public"."userLibrary" to "anon";

grant insert on table "public"."userLibrary" to "anon";

grant references on table "public"."userLibrary" to "anon";

grant select on table "public"."userLibrary" to "anon";

grant trigger on table "public"."userLibrary" to "anon";

grant truncate on table "public"."userLibrary" to "anon";

grant update on table "public"."userLibrary" to "anon";

grant delete on table "public"."userLibrary" to "authenticated";

grant insert on table "public"."userLibrary" to "authenticated";

grant references on table "public"."userLibrary" to "authenticated";

grant select on table "public"."userLibrary" to "authenticated";

grant trigger on table "public"."userLibrary" to "authenticated";

grant truncate on table "public"."userLibrary" to "authenticated";

grant update on table "public"."userLibrary" to "authenticated";

grant delete on table "public"."userLibrary" to "service_role";

grant insert on table "public"."userLibrary" to "service_role";

grant references on table "public"."userLibrary" to "service_role";

grant select on table "public"."userLibrary" to "service_role";

grant trigger on table "public"."userLibrary" to "service_role";

grant truncate on table "public"."userLibrary" to "service_role";

grant update on table "public"."userLibrary" to "service_role";

grant delete on table "public"."userQueries" to "anon";

grant insert on table "public"."userQueries" to "anon";

grant references on table "public"."userQueries" to "anon";

grant select on table "public"."userQueries" to "anon";

grant trigger on table "public"."userQueries" to "anon";

grant truncate on table "public"."userQueries" to "anon";

grant update on table "public"."userQueries" to "anon";

grant delete on table "public"."userQueries" to "authenticated";

grant insert on table "public"."userQueries" to "authenticated";

grant references on table "public"."userQueries" to "authenticated";

grant select on table "public"."userQueries" to "authenticated";

grant trigger on table "public"."userQueries" to "authenticated";

grant truncate on table "public"."userQueries" to "authenticated";

grant update on table "public"."userQueries" to "authenticated";

grant delete on table "public"."userQueries" to "service_role";

grant insert on table "public"."userQueries" to "service_role";

grant references on table "public"."userQueries" to "service_role";

grant select on table "public"."userQueries" to "service_role";

grant trigger on table "public"."userQueries" to "service_role";

grant truncate on table "public"."userQueries" to "service_role";

grant update on table "public"."userQueries" to "service_role";


  create policy "Enable insert for authenticated users only"
  on "public"."explanations"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."explanations"
  as permissive
  for select
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."llmCallTracking"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable insert for users based on user_id"
  on "public"."llmCallTracking"
  as permissive
  for insert
  to public
with check ((( SELECT auth.uid() AS uid) = userid));



  create policy "Enable insert for authenticated users only"
  on "public"."topics"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable read access for all users"
  on "public"."topics"
  as permissive
  for select
  to public
using (true);



  create policy "Enable insert for authenticated users only"
  on "public"."userExplanationEvents"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable insert for users based on user_id"
  on "public"."userExplanationEvents"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = userid));



  create policy "Enable insert for authenticated users only"
  on "public"."userLibrary"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable users to view their own data only"
  on "public"."userLibrary"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = userid));



  create policy "Enable insert for authenticated users only"
  on "public"."userQueries"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Enable insert for users based on user_id"
  on "public"."userQueries"
  as permissive
  for insert
  to authenticated
with check ((( SELECT auth.uid() AS uid) = userid));



  create policy "Enable users to view their own data only"
  on "public"."userQueries"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = userid));



