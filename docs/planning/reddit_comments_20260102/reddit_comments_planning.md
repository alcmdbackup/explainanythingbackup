# Reddit-Style Comments Planning

## 1. Background

ExplainAnything is an AI-powered educational content platform where users search topics and receive AI-generated explanations. Currently, users can save explanations to their library and provide feedback through tags. Adding a Reddit-style comments system will enable richer community engagement, allowing users to discuss, ask questions, and share insights directly on explanations.

## 2. Problem

Users currently have no way to discuss explanations with each other. The only interaction is saving to library or modifying tags. A threaded comments system would allow users to ask clarifying questions, share additional context, correct errors, and build community around content. This aligns with the product principle of "Maximize Feedback" to algorithmically improve content.

## 3. Options Considered

### Data Model Options

| Model | Read | Write | Chosen |
|-------|------|-------|--------|
| Adjacency List (parent_id only) | O(n) recursive | O(1) | No - slow reads |
| Materialized Path | O(1) with LIKE | O(depth) | **Yes - hybrid** |
| Nested Sets | O(1) | O(n) | No - complex writes |
| Closure Table | O(1) | O(depth) | No - over-engineered |

**Decision**: Hybrid Adjacency List + Materialized Path
- `parent_id` for simple navigation
- `path` (e.g., "1.5.12") for efficient subtree queries

### Vote Storage Options

| Approach | Pros | Cons | Chosen |
|----------|------|------|--------|
| Calculate on read | Always accurate | Slow for large threads | No |
| Denormalized counts + triggers | Fast reads | Slight write overhead | **Yes** |
| Background job aggregation | Decoupled | Eventually consistent | No |

**Decision**: Denormalized with triggers - vote counts stored on comments, updated via triggers

## 4. Phased Execution Plan

### Phase 1: Database Schema & Migration
**Files to create:**
- `supabase/migrations/20260102000001_comments_system.sql`

**Implementation:**
```sql
-- ============================================================================
-- TABLES
-- ============================================================================

-- comments table
-- Note: author_id uses UUID without FK to auth.users (matches existing pattern in userLibrary, userQueries)
-- Note: path uses DEFAULT '__pending__' to avoid NULL race condition window during trigger execution
CREATE TABLE public.comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  explanation_id BIGINT NOT NULL REFERENCES public.explanations(id) ON DELETE CASCADE,
  parent_id BIGINT REFERENCES public.comments(id) ON DELETE CASCADE,
  author_id UUID NOT NULL,  -- No FK to auth.users (matches existing codebase pattern)
  path TEXT NOT NULL DEFAULT '__pending__',  -- Set by AFTER INSERT trigger, never NULL
  depth SMALLINT NOT NULL DEFAULT 0 CHECK (depth >= 0 AND depth <= 10),
  content TEXT NOT NULL CHECK (char_length(content) <= 10000),
  upvotes INTEGER NOT NULL DEFAULT 0 CHECK (upvotes >= 0),
  downvotes INTEGER NOT NULL DEFAULT 0 CHECK (downvotes >= 0),
  net_score INTEGER GENERATED ALWAYS AS (upvotes - downvotes) STORED,
  is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
  is_edited BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- comment_votes table
CREATE TABLE public.comment_votes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  comment_id BIGINT NOT NULL REFERENCES public.comments(id) ON DELETE CASCADE,
  user_id UUID NOT NULL,  -- No FK to auth.users (matches existing codebase pattern)
  vote_value SMALLINT NOT NULL CHECK (vote_value IN (-1, 1)),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE(comment_id, user_id)
);

-- ============================================================================
-- INDEXES
-- ============================================================================

CREATE INDEX idx_comments_explanation_id ON public.comments(explanation_id);
CREATE INDEX idx_comments_parent_id ON public.comments(parent_id) WHERE parent_id IS NOT NULL;
CREATE INDEX idx_comments_author_id ON public.comments(author_id);
CREATE INDEX idx_comments_path ON public.comments USING btree(path text_pattern_ops);
CREATE INDEX idx_comments_explanation_score ON public.comments(explanation_id, net_score DESC) WHERE is_deleted = FALSE;
CREATE INDEX idx_comments_explanation_created ON public.comments(explanation_id, created_at DESC) WHERE is_deleted = FALSE;
CREATE INDEX idx_comment_votes_comment_id ON public.comment_votes(comment_id);
CREATE INDEX idx_comment_votes_user_id ON public.comment_votes(user_id);

-- ============================================================================
-- RLS POLICIES
-- ============================================================================

ALTER TABLE public.comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.comment_votes ENABLE ROW LEVEL SECURITY;

-- Comments: Authenticated users can read all non-deleted comments
CREATE POLICY "Authenticated users can read comments"
  ON public.comments FOR SELECT
  TO authenticated
  USING (is_deleted = FALSE OR author_id = auth.uid());

-- Comments: Users can create their own comments
CREATE POLICY "Users can create their own comments"
  ON public.comments FOR INSERT
  TO authenticated
  WITH CHECK (author_id = auth.uid());

-- Comments: Users can update their own comments
CREATE POLICY "Users can update their own comments"
  ON public.comments FOR UPDATE
  TO authenticated
  USING (author_id = auth.uid())
  WITH CHECK (author_id = auth.uid());

-- Votes: Users can read all votes (needed for aggregation queries)
CREATE POLICY "Users can read votes"
  ON public.comment_votes FOR SELECT
  TO authenticated
  USING (true);

-- Votes: Users can create their own votes
CREATE POLICY "Users can create their own votes"
  ON public.comment_votes FOR INSERT
  TO authenticated
  WITH CHECK (user_id = auth.uid());

-- Votes: Users can update their own votes
CREATE POLICY "Users can update their own votes"
  ON public.comment_votes FOR UPDATE
  TO authenticated
  USING (user_id = auth.uid())
  WITH CHECK (user_id = auth.uid());

-- Votes: Users can delete their own votes
CREATE POLICY "Users can delete their own votes"
  ON public.comment_votes FOR DELETE
  TO authenticated
  USING (user_id = auth.uid());

-- ============================================================================
-- TRIGGER FUNCTIONS
-- Note: SECURITY DEFINER functions must set search_path = '' per security guidelines
-- ============================================================================

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION public.update_comments_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_comments_updated_at
  BEFORE UPDATE ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.update_comments_updated_at();

-- Update vote counts on comments when votes change
-- Uses SECURITY DEFINER to bypass RLS for count updates
CREATE OR REPLACE FUNCTION public.update_comment_vote_counts()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = ''
AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE public.comments SET
      upvotes = upvotes + CASE WHEN NEW.vote_value = 1 THEN 1 ELSE 0 END,
      downvotes = downvotes + CASE WHEN NEW.vote_value = -1 THEN 1 ELSE 0 END
    WHERE id = NEW.comment_id;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    IF OLD.vote_value != NEW.vote_value THEN
      UPDATE public.comments SET
        upvotes = upvotes
          - CASE WHEN OLD.vote_value = 1 THEN 1 ELSE 0 END
          + CASE WHEN NEW.vote_value = 1 THEN 1 ELSE 0 END,
        downvotes = downvotes
          - CASE WHEN OLD.vote_value = -1 THEN 1 ELSE 0 END
          + CASE WHEN NEW.vote_value = -1 THEN 1 ELSE 0 END
      WHERE id = NEW.comment_id;
    END IF;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE public.comments SET
      upvotes = upvotes - CASE WHEN OLD.vote_value = 1 THEN 1 ELSE 0 END,
      downvotes = downvotes - CASE WHEN OLD.vote_value = -1 THEN 1 ELSE 0 END
    WHERE id = OLD.comment_id;
    RETURN OLD;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_update_comment_votes
  AFTER INSERT OR UPDATE OR DELETE ON public.comment_votes
  FOR EACH ROW EXECUTE FUNCTION public.update_comment_vote_counts();

-- Set comment path and depth AFTER INSERT (uses SERIALIZABLE for race condition safety)
-- Path format: "parent_path.id" (e.g., "1.5.12")
CREATE OR REPLACE FUNCTION public.set_comment_path_and_depth()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = ''
AS $$
DECLARE
  parent_path TEXT;
  parent_depth SMALLINT;
BEGIN
  IF NEW.parent_id IS NULL THEN
    -- Top-level comment
    UPDATE public.comments
    SET path = NEW.id::TEXT, depth = 0
    WHERE id = NEW.id;
  ELSE
    -- Reply - get parent info with row lock to prevent race conditions
    SELECT path, depth INTO parent_path, parent_depth
    FROM public.comments
    WHERE id = NEW.parent_id
    FOR UPDATE;

    IF parent_path IS NULL THEN
      RAISE EXCEPTION 'Parent comment % not found', NEW.parent_id;
    END IF;

    IF parent_depth >= 10 THEN
      RAISE EXCEPTION 'Maximum comment nesting depth (10) exceeded';
    END IF;

    UPDATE public.comments
    SET path = parent_path || '.' || NEW.id::TEXT,
        depth = parent_depth + 1
    WHERE id = NEW.id;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_comment_path
  AFTER INSERT ON public.comments
  FOR EACH ROW EXECUTE FUNCTION public.set_comment_path_and_depth();
```

**Verification:**
1. Run `supabase db reset` locally
2. Verify tables in Supabase Studio
3. Test RLS: confirm user can only modify own comments/votes
4. Test triggers: confirm vote counts update correctly

---

### Phase 2: Zod Schemas
**Files to create:**
- `src/lib/schemas/commentSchemas.ts`

**File header (per CLAUDE.md):**
```typescript
/**
 * Zod schemas and TypeScript types for the comments system.
 * Defines validation for comments, votes, and UI state following project schema patterns.
 */
```

**Implementation:**
```typescript
import { z } from 'zod';

// Vote value enum
export const VoteValueSchema = z.union([z.literal(-1), z.literal(1)]);
export type VoteValue = z.infer<typeof VoteValueSchema>;

// Sort mode enum
export const CommentSortModeSchema = z.enum(['top', 'new', 'controversial']);
export type CommentSortMode = z.infer<typeof CommentSortModeSchema>;

// Insert schema (no auto-generated fields)
export const CommentInsertSchema = z.object({
  explanation_id: z.number().int().positive(),
  parent_id: z.number().int().positive().nullable(),
  content: z.string().min(1).max(10000),
});
export type CommentInsertType = z.infer<typeof CommentInsertSchema>;

// Full DB schema (extends insert with DB-generated fields)
export const CommentFullDbSchema = CommentInsertSchema.extend({
  id: z.number().int().positive(),
  author_id: z.string().uuid(),
  path: z.string(),
  depth: z.number().int().min(0).max(10),
  upvotes: z.number().int().min(0),
  downvotes: z.number().int().min(0),
  net_score: z.number().int(),
  is_deleted: z.boolean(),
  is_edited: z.boolean(),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type CommentFullDbType = z.infer<typeof CommentFullDbSchema>;

// UI schema (extends DB with user vote and nested replies)
// Note: For recursive types, define the type explicitly first, then use z.lazy() for the schema
export type CommentUIType = z.infer<typeof CommentFullDbSchema> & {
  user_vote: VoteValue | null;
  replies: CommentUIType[];
  is_collapsed: boolean;
};

// Schema uses explicit type annotation with z.lazy for self-reference
const baseCommentUISchema = CommentFullDbSchema.extend({
  user_vote: VoteValueSchema.nullable(),
  is_collapsed: z.boolean().default(false),
});

export const CommentUISchema: z.ZodType<CommentUIType> = baseCommentUISchema.extend({
  replies: z.lazy(() => z.array(CommentUISchema)),
});

// Vote schemas
export const CommentVoteInsertSchema = z.object({
  comment_id: z.number().int().positive(),
  vote_value: VoteValueSchema,
});
export type CommentVoteInsertType = z.infer<typeof CommentVoteInsertSchema>;
```

**Verification:** `npm run type-check` passes

---

### Phase 3: Service Layer
**Files to create:**
- `src/lib/services/comments.ts`
- `src/lib/services/commentVotes.ts`

**File header (per CLAUDE.md):**
```typescript
/**
 * Service layer for comment CRUD operations.
 * Handles database interactions for threaded comments with tree building.
 */
```

**Key patterns (from userLibrary.ts):**
- Use `assertUserId(userId, 'functionName')` for auth validation
- Use `createSupabaseServerClient()` for user-scoped queries
- Use `logger.error()` for error logging with context
- Return full objects after insert with `.select().single()`

**Implementation - comments.ts:**
```typescript
import { createSupabaseServerClient } from '@/lib/utils/supabase/server';
import { logger } from '@/lib/server_utilities';
import { assertUserId } from '@/lib/utils/validation';
import {
  CommentInsertSchema,
  CommentInsertType,
  CommentFullDbType,
  CommentUIType,
  CommentSortMode,
  VoteValue,
} from '@/lib/schemas/commentSchemas';

export async function createComment(
  data: CommentInsertType,
  authorId: string
): Promise<CommentFullDbType> {
  assertUserId(authorId, 'createComment');
  const supabase = await createSupabaseServerClient();

  // Validate input
  const validated = CommentInsertSchema.parse(data);

  // Check parent depth if replying
  if (validated.parent_id) {
    const { data: parent, error: parentError } = await supabase
      .from('comments')
      .select('depth')
      .eq('id', validated.parent_id)
      .single();

    if (parentError || !parent) {
      logger.error('Parent comment not found', { parent_id: validated.parent_id });
      throw new Error('Parent comment not found');
    }

    if (parent.depth >= 10) {
      throw new Error('Maximum nesting depth (10) exceeded');
    }
  }

  // Note: path field uses DEFAULT '__pending__' from schema, then trigger updates it
  // Do NOT pass path here - let the DEFAULT handle it to avoid inconsistency
  const { data: comment, error } = await supabase
    .from('comments')
    .insert({
      explanation_id: validated.explanation_id,
      parent_id: validated.parent_id,
      author_id: authorId,
      content: validated.content,
      // path: omitted - uses schema DEFAULT '__pending__', trigger sets final value
    })
    .select()
    .single();

  if (error) {
    logger.error('Error creating comment', { error: error.message });
    throw error;
  }

  return comment;
}

export async function getCommentsForExplanation(
  explanationId: number,
  userId: string | null,
  sortMode: CommentSortMode = 'top'
): Promise<CommentUIType[]> {
  const supabase = await createSupabaseServerClient();

  // Fetch all comments for explanation
  const { data: comments, error } = await supabase
    .from('comments')
    .select('*')
    .eq('explanation_id', explanationId)
    .eq('is_deleted', false);

  if (error) {
    logger.error('Error fetching comments', { error: error.message });
    throw error;
  }

  if (!comments?.length) return [];

  // Get user's votes if authenticated
  let userVotes = new Map<number, VoteValue>();
  if (userId) {
    const { data: votes } = await supabase
      .from('comment_votes')
      .select('comment_id, vote_value')
      .eq('user_id', userId)
      .in('comment_id', comments.map(c => c.id));

    if (votes) {
      votes.forEach(v => userVotes.set(v.comment_id, v.vote_value as VoteValue));
    }
  }

  return buildCommentTree(comments, userVotes, sortMode);
}

// Helper: Build nested tree from flat array
function buildCommentTree(
  comments: CommentFullDbType[],
  userVotes: Map<number, VoteValue>,
  sortMode: CommentSortMode
): CommentUIType[] {
  // Create map of id -> UI comment with empty replies
  const commentMap = new Map<number, CommentUIType>();
  comments.forEach(c => {
    commentMap.set(c.id, {
      ...c,
      user_vote: userVotes.get(c.id) ?? null,
      replies: [],
      is_collapsed: false,
    });
  });

  // Build tree by linking children to parents
  const rootComments: CommentUIType[] = [];
  comments.forEach(c => {
    const uiComment = commentMap.get(c.id)!;
    if (c.parent_id === null) {
      rootComments.push(uiComment);
    } else {
      const parent = commentMap.get(c.parent_id);
      if (parent) {
        parent.replies.push(uiComment);
      }
    }
  });

  // Sort at each level
  const sortFn = getSortFunction(sortMode);
  const sortTree = (nodes: CommentUIType[]): void => {
    nodes.sort(sortFn);
    nodes.forEach(n => sortTree(n.replies));
  };
  sortTree(rootComments);

  return rootComments;
}

// Sort functions for different modes
function getSortFunction(mode: CommentSortMode): (a: CommentUIType, b: CommentUIType) => number {
  switch (mode) {
    case 'top':
      return (a, b) => b.net_score - a.net_score || new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    case 'new':
      return (a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
    case 'controversial':
      // Controversial = high engagement (many votes) with close to 50/50 split
      return (a, b) => {
        const aTotal = a.upvotes + a.downvotes;
        const bTotal = b.upvotes + b.downvotes;
        const aControversy = aTotal > 0 ? aTotal * (1 - Math.abs(a.net_score) / aTotal) : 0;
        const bControversy = bTotal > 0 ? bTotal * (1 - Math.abs(b.net_score) / bTotal) : 0;
        return bControversy - aControversy;
      };
    default:
      return (a, b) => b.net_score - a.net_score;
  }
}

export async function updateComment(
  commentId: number,
  userId: string,
  newContent: string
): Promise<CommentFullDbType> {
  assertUserId(userId, 'updateComment');
  const supabase = await createSupabaseServerClient();

  const { data: comment, error } = await supabase
    .from('comments')
    .update({ content: newContent, is_edited: true })
    .eq('id', commentId)
    .eq('author_id', userId)
    .select()
    .single();

  if (error) {
    logger.error('Error updating comment', { error: error.message, commentId });
    throw error;
  }

  return comment;
}

export async function deleteComment(
  commentId: number,
  userId: string
): Promise<void> {
  assertUserId(userId, 'deleteComment');
  const supabase = await createSupabaseServerClient();

  const { error } = await supabase
    .from('comments')
    .update({ is_deleted: true, content: '[deleted]' })
    .eq('id', commentId)
    .eq('author_id', userId);

  if (error) {
    logger.error('Error deleting comment', { error: error.message, commentId });
    throw error;
  }
}
```

**Implementation - commentVotes.ts:**
```typescript
export async function castVote(
  commentId: number,
  userId: string,
  voteValue: VoteValue
): Promise<VoteValue | null> {
  assertUserId(userId, 'castVote');
  const supabase = await createSupabaseServerClient();

  // Check existing vote
  const { data: existingVote } = await supabase
    .from('comment_votes')
    .select('id, vote_value')
    .eq('comment_id', commentId)
    .eq('user_id', userId)
    .maybeSingle();

  if (existingVote) {
    if (existingVote.vote_value === voteValue) {
      // Toggle off - delete vote
      await supabase.from('comment_votes').delete().eq('id', existingVote.id);
      return null;
    } else {
      // Change vote
      await supabase
        .from('comment_votes')
        .update({ vote_value: voteValue })
        .eq('id', existingVote.id);
      return voteValue;
    }
  } else {
    // New vote
    await supabase.from('comment_votes').insert({
      comment_id: commentId,
      user_id: userId,
      vote_value: voteValue,
    });
    return voteValue;
  }
}
```

**Verification:**
1. `npm run type-check` passes
2. Unit tests in `comments.test.ts` and `commentVotes.test.ts` pass

---

### Phase 4: Server Actions
**Files to create:**
- `src/actions/commentActions.ts`

**File header (per CLAUDE.md):**
```typescript
/**
 * Server actions for comment operations.
 * Wraps service layer with logging, request ID tracking, and error handling.
 */
'use server';
```

**Key patterns (from actions.ts):**
- Wrap with `withLogging(fn, 'actionName', { enabled: FILE_DEBUG })`
- Wrap with `serverReadRequestId()` for request tracing
- Return `{ success: boolean, data: T | null, error: ErrorType | null }`
- Use `handleError()` and `createInputError()` from `@/lib/errorHandling`

**Implementation:**
```typescript
'use server';

import { z } from 'zod';
import { serverReadRequestId } from '@/lib/serverReadRequestId';
import { withLogging } from '@/lib/logging/server/automaticServerLoggingBase';
import { handleError, createInputError } from '@/lib/errorHandling';
import {
  createComment,
  getCommentsForExplanation,
  updateComment,
  deleteComment,
} from '@/lib/services/comments';
import { castVote } from '@/lib/services/commentVotes';
import {
  CommentFullDbType,
  CommentUIType,
  CommentSortMode,
  VoteValue,
} from '@/lib/schemas/commentSchemas';

const FILE_DEBUG = true;

// ============================================================================
// Create Comment Action
// ============================================================================

// Input validation schema for createCommentAction
const CreateCommentParamsSchema = z.object({
  explanationId: z.number().int().positive(),
  parentId: z.number().int().positive().nullable(),
  content: z.string().min(1).max(10000),
  userId: z.string().uuid(),
});

const _createCommentAction = withLogging(
  async function createCommentAction(params: {
    explanationId: number;
    parentId: number | null;
    content: string;
    userId: string;
  }): Promise<{ success: boolean; data: CommentFullDbType | null; error: any }> {
    try {
      // Validate input with Zod schema
      const validationResult = CreateCommentParamsSchema.safeParse(params);
      if (!validationResult.success) {
        return {
          success: false,
          data: null,
          error: createInputError(validationResult.error.message),
        };
      }

      const validated = validationResult.data;

      const comment = await createComment(
        {
          explanation_id: validated.explanationId,
          parent_id: validated.parentId,
          content: validated.content,
        },
        validated.userId
      );

      return { success: true, data: comment, error: null };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: handleError(error, 'createCommentAction', params),
      };
    }
  },
  'createCommentAction',
  { enabled: FILE_DEBUG }
);

export const createCommentAction = serverReadRequestId(_createCommentAction);

// ============================================================================
// Get Comments Action
// ============================================================================

const _getCommentsAction = withLogging(
  async function getCommentsAction(params: {
    explanationId: number;
    userId: string | null;
    sortMode?: CommentSortMode;
  }): Promise<{ success: boolean; data: CommentUIType[] | null; error: any }> {
    try {
      const comments = await getCommentsForExplanation(
        params.explanationId,
        params.userId,
        params.sortMode ?? 'top'
      );
      return { success: true, data: comments, error: null };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: handleError(error, 'getCommentsAction', params),
      };
    }
  },
  'getCommentsAction',
  { enabled: FILE_DEBUG }
);

export const getCommentsAction = serverReadRequestId(_getCommentsAction);

// ============================================================================
// Update Comment Action
// ============================================================================

const _updateCommentAction = withLogging(
  async function updateCommentAction(params: {
    commentId: number;
    userId: string;
    content: string;
  }): Promise<{ success: boolean; data: CommentFullDbType | null; error: any }> {
    try {
      if (!params.userId) {
        return {
          success: false,
          data: null,
          error: createInputError('User must be authenticated to edit comments'),
        };
      }

      const comment = await updateComment(params.commentId, params.userId, params.content);
      return { success: true, data: comment, error: null };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: handleError(error, 'updateCommentAction', params),
      };
    }
  },
  'updateCommentAction',
  { enabled: FILE_DEBUG }
);

export const updateCommentAction = serverReadRequestId(_updateCommentAction);

// ============================================================================
// Delete Comment Action (soft delete)
// ============================================================================

const _deleteCommentAction = withLogging(
  async function deleteCommentAction(params: {
    commentId: number;
    userId: string;
  }): Promise<{ success: boolean; data: null; error: any }> {
    try {
      if (!params.userId) {
        return {
          success: false,
          data: null,
          error: createInputError('User must be authenticated to delete comments'),
        };
      }

      await deleteComment(params.commentId, params.userId);
      return { success: true, data: null, error: null };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: handleError(error, 'deleteCommentAction', params),
      };
    }
  },
  'deleteCommentAction',
  { enabled: FILE_DEBUG }
);

export const deleteCommentAction = serverReadRequestId(_deleteCommentAction);

// ============================================================================
// Cast Vote Action
// ============================================================================

const _castVoteAction = withLogging(
  async function castVoteAction(params: {
    commentId: number;
    userId: string;
    voteValue: VoteValue;
  }): Promise<{ success: boolean; data: VoteValue | null; error: any }> {
    try {
      if (!params.userId) {
        return {
          success: false,
          data: null,
          error: createInputError('User must be authenticated to vote'),
        };
      }

      const result = await castVote(params.commentId, params.userId, params.voteValue);
      return { success: true, data: result, error: null };
    } catch (error) {
      return {
        success: false,
        data: null,
        error: handleError(error, 'castVoteAction', params),
      };
    }
  },
  'castVoteAction',
  { enabled: FILE_DEBUG }
);

export const castVoteAction = serverReadRequestId(_castVoteAction);
```

**Verification:**
1. `npm run type-check` passes
2. `npm test -- commentActions` passes

---

### Phase 5: Frontend State
**Files to create:**
- `src/reducers/commentsReducer.ts`
- `src/hooks/useComments.ts`

**File header (per CLAUDE.md):**
```typescript
/**
 * Reducer for managing comments state including tree structure, loading states,
 * UI interactions (collapse, reply, edit), and optimistic vote updates.
 */
```

**Implementation - commentsReducer.ts:**
```typescript
import { CommentUIType, CommentSortMode, VoteValue } from '@/lib/schemas/commentSchemas';

// State type
export interface CommentsState {
  comments: CommentUIType[];
  isLoading: boolean;
  error: string | null;
  sortMode: CommentSortMode;
  replyingTo: number | null;  // comment id being replied to
  editingId: number | null;   // comment id being edited
}

// Action types
export type CommentsAction =
  | { type: 'LOAD_COMMENTS'; payload: CommentUIType[] }
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_SORT_MODE'; payload: CommentSortMode }
  | { type: 'TOGGLE_COLLAPSE'; payload: number }
  | { type: 'SET_REPLYING_TO'; payload: number | null }
  | { type: 'SET_EDITING'; payload: number | null }
  | { type: 'ADD_COMMENT'; payload: { comment: CommentUIType; parentId: number | null } }
  | { type: 'UPDATE_COMMENT'; payload: { id: number; content: string } }
  | { type: 'DELETE_COMMENT'; payload: number }
  | { type: 'UPDATE_VOTE'; payload: { id: number; vote: VoteValue | null; scoreDelta: number } };

// Initial state factory
export const createInitialState = (): CommentsState => ({
  comments: [],
  isLoading: false,
  error: null,
  sortMode: 'top',
  replyingTo: null,
  editingId: null,
});

// Reducer
export function commentsReducer(state: CommentsState, action: CommentsAction): CommentsState {
  switch (action.type) {
    case 'LOAD_COMMENTS':
      return { ...state, comments: action.payload, isLoading: false, error: null };

    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };

    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };

    case 'SET_SORT_MODE':
      return { ...state, sortMode: action.payload };

    case 'TOGGLE_COLLAPSE':
      return {
        ...state,
        comments: updateCommentInTree(state.comments, action.payload, (c) => ({
          ...c,
          is_collapsed: !c.is_collapsed,
        })),
      };

    case 'SET_REPLYING_TO':
      return { ...state, replyingTo: action.payload, editingId: null };

    case 'SET_EDITING':
      return { ...state, editingId: action.payload, replyingTo: null };

    case 'ADD_COMMENT': {
      const { comment, parentId } = action.payload;
      if (parentId === null) {
        return { ...state, comments: [comment, ...state.comments], replyingTo: null };
      }
      return {
        ...state,
        comments: updateCommentInTree(state.comments, parentId, (c) => ({
          ...c,
          replies: [comment, ...c.replies],
        })),
        replyingTo: null,
      };
    }

    case 'UPDATE_COMMENT':
      return {
        ...state,
        comments: updateCommentInTree(state.comments, action.payload.id, (c) => ({
          ...c,
          content: action.payload.content,
          is_edited: true,
        })),
        editingId: null,
      };

    case 'DELETE_COMMENT':
      return {
        ...state,
        comments: updateCommentInTree(state.comments, action.payload, (c) => ({
          ...c,
          content: '[deleted]',
          is_deleted: true,
        })),
      };

    case 'UPDATE_VOTE': {
      // Calculate vote count changes correctly for all transitions:
      // null -> 1: upvotes +1
      // null -> -1: downvotes +1
      // 1 -> null: upvotes -1
      // -1 -> null: downvotes -1
      // 1 -> -1: upvotes -1, downvotes +1
      // -1 -> 1: downvotes -1, upvotes +1
      const { id, vote: newVote, scoreDelta } = action.payload;
      return {
        ...state,
        comments: updateCommentInTree(state.comments, id, (c) => {
          const oldVote = c.user_vote;
          let upvoteDelta = 0;
          let downvoteDelta = 0;

          // Remove old vote effect
          if (oldVote === 1) upvoteDelta -= 1;
          if (oldVote === -1) downvoteDelta -= 1;

          // Add new vote effect
          if (newVote === 1) upvoteDelta += 1;
          if (newVote === -1) downvoteDelta += 1;

          return {
            ...c,
            user_vote: newVote,
            net_score: c.net_score + scoreDelta,
            upvotes: c.upvotes + upvoteDelta,
            downvotes: c.downvotes + downvoteDelta,
          };
        }),
      };
    }

    default:
      return state;
  }
}

// Helper: Recursively update a comment in the tree
function updateCommentInTree(
  comments: CommentUIType[],
  targetId: number,
  updater: (comment: CommentUIType) => CommentUIType
): CommentUIType[] {
  return comments.map((comment) => {
    if (comment.id === targetId) {
      return updater(comment);
    }
    if (comment.replies.length > 0) {
      return {
        ...comment,
        replies: updateCommentInTree(comment.replies, targetId, updater),
      };
    }
    return comment;
  });
}
```

**Implementation - useComments.ts:**
```typescript
/**
 * Hook for managing comments state and actions.
 * Wraps the reducer with server action calls and loading state management.
 */
import { useReducer, useCallback, useEffect, useRef } from 'react';
import { commentsReducer, createInitialState, CommentsState } from '@/reducers/commentsReducer';
import {
  createCommentAction,
  getCommentsAction,
  updateCommentAction,
  deleteCommentAction,
  castVoteAction,
} from '@/actions/commentActions';
import { CommentSortMode, VoteValue } from '@/lib/schemas/commentSchemas';

interface UseCommentsParams {
  explanationId: number;
  userId: string | null;
}

export function useComments({ explanationId, userId }: UseCommentsParams) {
  const [state, dispatch] = useReducer(commentsReducer, undefined, createInitialState);
  // Use ref to track sort mode without causing infinite loops
  const sortModeRef = useRef(state.sortMode);
  sortModeRef.current = state.sortMode;

  // Load comments - stable callback, uses ref for sortMode to avoid infinite loop
  const loadComments = useCallback(async () => {
    dispatch({ type: 'SET_LOADING', payload: true });
    const result = await getCommentsAction({
      explanationId,
      userId,
      sortMode: sortModeRef.current,
    });
    if (result.success && result.data) {
      dispatch({ type: 'LOAD_COMMENTS', payload: result.data });
    } else {
      dispatch({ type: 'SET_ERROR', payload: result.error?.message ?? 'Failed to load comments' });
    }
  }, [explanationId, userId]); // Note: sortMode NOT in deps - uses ref instead

  // Load on mount
  useEffect(() => {
    loadComments();
  }, [loadComments]);

  // Reload when sort mode changes
  useEffect(() => {
    // Skip initial render (handled by mount effect above)
    loadComments();
  }, [state.sortMode]); // eslint-disable-line react-hooks/exhaustive-deps

  // Actions
  const createComment = useCallback(async (content: string, parentId: number | null) => {
    if (!userId) return;
    const result = await createCommentAction({
      explanationId,
      parentId,
      content,
      userId,
    });
    if (result.success && result.data) {
      dispatch({
        type: 'ADD_COMMENT',
        payload: {
          comment: { ...result.data, user_vote: null, replies: [], is_collapsed: false },
          parentId,
        },
      });
    }
  }, [explanationId, userId]);

  const updateComment = useCallback(async (commentId: number, content: string) => {
    if (!userId) return;
    const result = await updateCommentAction({ commentId, userId, content });
    if (result.success) {
      dispatch({ type: 'UPDATE_COMMENT', payload: { id: commentId, content } });
    }
  }, [userId]);

  const deleteComment = useCallback(async (commentId: number) => {
    if (!userId) return;
    const result = await deleteCommentAction({ commentId, userId });
    if (result.success) {
      dispatch({ type: 'DELETE_COMMENT', payload: commentId });
    }
  }, [userId]);

  const vote = useCallback(async (commentId: number, voteValue: VoteValue) => {
    if (!userId) return;
    const result = await castVoteAction({ commentId, userId, voteValue });
    if (result.success) {
      // Calculate score delta based on previous vote and new vote
      const prevVote = findCommentVote(state.comments, commentId);
      const scoreDelta = calculateScoreDelta(prevVote, result.data);
      dispatch({
        type: 'UPDATE_VOTE',
        payload: { id: commentId, vote: result.data, scoreDelta },
      });
    }
  }, [userId, state.comments]);

  const setSortMode = useCallback((mode: CommentSortMode) => {
    dispatch({ type: 'SET_SORT_MODE', payload: mode });
  }, []);

  const toggleCollapse = useCallback((commentId: number) => {
    dispatch({ type: 'TOGGLE_COLLAPSE', payload: commentId });
  }, []);

  const setReplyingTo = useCallback((commentId: number | null) => {
    dispatch({ type: 'SET_REPLYING_TO', payload: commentId });
  }, []);

  const setEditing = useCallback((commentId: number | null) => {
    dispatch({ type: 'SET_EDITING', payload: commentId });
  }, []);

  return {
    state,
    actions: {
      loadComments,
      createComment,
      updateComment,
      deleteComment,
      vote,
      setSortMode,
      toggleCollapse,
      setReplyingTo,
      setEditing,
    },
  };
}

// Helpers
function findCommentVote(comments: CommentsState['comments'], id: number): VoteValue | null {
  for (const c of comments) {
    if (c.id === id) return c.user_vote;
    const found = findCommentVote(c.replies, id);
    if (found !== undefined) return found;
  }
  return null;
}

function calculateScoreDelta(prevVote: VoteValue | null, newVote: VoteValue | null): number {
  const prev = prevVote ?? 0;
  const next = newVote ?? 0;
  return next - prev;
}
```

**Verification:**
1. `npm run type-check` passes
2. `npm test -- commentsReducer` passes

---

### Phase 6: UI Components
**Files to create:**
- `src/components/comments/CommentsSection.tsx`
- `src/components/comments/CommentList.tsx`
- `src/components/comments/Comment.tsx`
- `src/components/comments/CommentForm.tsx`
- `src/components/comments/CommentVotes.tsx`
- `src/components/comments/CommentActions.tsx`

**File header (per CLAUDE.md):**
```typescript
/**
 * [Component name] - [brief description]
 * Part of the Reddit-style threaded comments system.
 */
```

**Implementation - CommentsSection.tsx:**
```tsx
/**
 * CommentsSection - Main container for the comments feature.
 * Manages state via useComments hook and renders comment tree.
 */
'use client';

import { useComments } from '@/hooks/useComments';
import { CommentList } from './CommentList';
import { CommentForm } from './CommentForm';
import { CommentSortMode } from '@/lib/schemas/commentSchemas';

interface CommentsSectionProps {
  explanationId: number;
  userId: string | null;
}

export function CommentsSection({ explanationId, userId }: CommentsSectionProps) {
  const { state, actions } = useComments({ explanationId, userId });

  if (state.isLoading) {
    return <div className="animate-pulse">Loading comments...</div>;
  }

  if (state.error) {
    return <div className="text-red-500">Error: {state.error}</div>;
  }

  return (
    <div className="comments-section" data-testid="comments-section">
      {/* Header with count and sort */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold">
          {state.comments.length} {state.comments.length === 1 ? 'Comment' : 'Comments'}
        </h3>
        <select
          value={state.sortMode}
          onChange={(e) => actions.setSortMode(e.target.value as CommentSortMode)}
          className="border rounded px-2 py-1"
          data-testid="comment-sort"
        >
          <option value="top">Top</option>
          <option value="new">New</option>
          <option value="controversial">Controversial</option>
        </select>
      </div>

      {/* New comment form (top-level only if authenticated) */}
      {userId && (
        <CommentForm
          onSubmit={(content) => actions.createComment(content, null)}
          placeholder="Add a comment..."
          data-testid="comment-input"
        />
      )}

      {/* Comment tree */}
      <CommentList
        comments={state.comments}
        replyingTo={state.replyingTo}
        editingId={state.editingId}
        userId={userId}
        actions={actions}
      />
    </div>
  );
}
```

**Implementation - Comment.tsx:**
```tsx
/**
 * Comment - Recursive component rendering a single comment and its replies.
 * Handles depth-based indentation and collapse/expand functionality.
 */
'use client';

import { CommentUIType, VoteValue } from '@/lib/schemas/commentSchemas';
import { CommentVotes } from './CommentVotes';
import { CommentActions } from './CommentActions';
import { CommentForm } from './CommentForm';
import { CommentList } from './CommentList';
import { formatDistanceToNow } from 'date-fns';

interface CommentProps {
  comment: CommentUIType;
  replyingTo: number | null;
  editingId: number | null;
  userId: string | null;
  actions: {
    createComment: (content: string, parentId: number | null) => Promise<void>;
    updateComment: (id: number, content: string) => Promise<void>;
    deleteComment: (id: number) => Promise<void>;
    vote: (id: number, value: VoteValue) => Promise<void>;
    toggleCollapse: (id: number) => void;
    setReplyingTo: (id: number | null) => void;
    setEditing: (id: number | null) => void;
  };
}

export function Comment({ comment, replyingTo, editingId, userId, actions }: CommentProps) {
  const isEditing = editingId === comment.id;
  const isReplying = replyingTo === comment.id;
  const canModify = userId === comment.author_id && !comment.is_deleted;
  const isMaxDepth = comment.depth >= 10;

  return (
    <div
      className="comment"
      style={{ marginLeft: `${comment.depth * 16}px` }}
      data-testid={`comment-${comment.id}`}
    >
      <div className="flex gap-2">
        {/* Votes */}
        <CommentVotes
          upvotes={comment.upvotes}
          downvotes={comment.downvotes}
          netScore={comment.net_score}
          userVote={comment.user_vote}
          onVote={(value) => actions.vote(comment.id, value)}
          disabled={!userId || comment.is_deleted}
        />

        <div className="flex-1">
          {/* Meta: author, time, edited indicator */}
          <div className="text-sm text-gray-500">
            <span className="font-medium">{comment.author_id.slice(0, 8)}...</span>
            <span className="mx-1">â€¢</span>
            <span>{formatDistanceToNow(new Date(comment.created_at), { addSuffix: true })}</span>
            {comment.is_edited && <span className="ml-1">(edited)</span>}
          </div>

          {/* Content or edit form */}
          {isEditing ? (
            <CommentForm
              initialValue={comment.content}
              onSubmit={(content) => actions.updateComment(comment.id, content)}
              onCancel={() => actions.setEditing(null)}
            />
          ) : (
            // SAFE: React auto-escapes - no XSS risk
            <p className="my-2">{comment.is_deleted ? '[deleted]' : comment.content}</p>
          )}

          {/* Actions: reply, edit, delete */}
          {!comment.is_deleted && (
            <CommentActions
              canReply={!!userId && !isMaxDepth}
              canEdit={canModify}
              canDelete={canModify}
              isCollapsed={comment.is_collapsed}
              replyCount={comment.replies.length}
              onReply={() => actions.setReplyingTo(comment.id)}
              onEdit={() => actions.setEditing(comment.id)}
              onDelete={() => actions.deleteComment(comment.id)}
              onToggleCollapse={() => actions.toggleCollapse(comment.id)}
            />
          )}

          {/* Reply form */}
          {isReplying && (
            <CommentForm
              onSubmit={(content) => actions.createComment(content, comment.id)}
              onCancel={() => actions.setReplyingTo(null)}
              placeholder="Write a reply..."
              autoFocus
            />
          )}
        </div>
      </div>

      {/* Nested replies (recursive) */}
      {!comment.is_collapsed && comment.replies.length > 0 && (
        <CommentList
          comments={comment.replies}
          replyingTo={replyingTo}
          editingId={editingId}
          userId={userId}
          actions={actions}
        />
      )}
    </div>
  );
}
```

**Implementation - CommentVotes.tsx:**
```tsx
/**
 * CommentVotes - Upvote/downvote arrows with score display.
 * Handles vote toggling and visual feedback for user's current vote.
 */
'use client';

import { VoteValue } from '@/lib/schemas/commentSchemas';
import { ChevronUp, ChevronDown } from 'lucide-react';
import { cn } from '@/lib/utils';

interface CommentVotesProps {
  upvotes: number;
  downvotes: number;
  netScore: number;
  userVote: VoteValue | null;
  onVote: (value: VoteValue) => void;
  disabled?: boolean;
}

export function CommentVotes({
  netScore,
  userVote,
  onVote,
  disabled,
}: CommentVotesProps) {
  return (
    <div className="flex flex-col items-center gap-0.5" data-testid="comment-votes">
      <button
        onClick={() => onVote(1)}
        disabled={disabled}
        className={cn(
          'p-0.5 rounded hover:bg-gray-100',
          userVote === 1 && 'text-orange-500'
        )}
        data-testid="upvote-btn"
        aria-label="Upvote"
      >
        <ChevronUp size={18} />
      </button>
      <span className={cn(
        'text-sm font-medium',
        userVote === 1 && 'text-orange-500',
        userVote === -1 && 'text-blue-500'
      )}>
        {netScore}
      </span>
      <button
        onClick={() => onVote(-1)}
        disabled={disabled}
        className={cn(
          'p-0.5 rounded hover:bg-gray-100',
          userVote === -1 && 'text-blue-500'
        )}
        data-testid="downvote-btn"
        aria-label="Downvote"
      >
        <ChevronDown size={18} />
      </button>
    </div>
  );
}
```

**Implementation - CommentList.tsx:**
```tsx
/**
 * CommentList - Renders a list of comments, used recursively for replies.
 * Simple mapping component that delegates to Comment for each item.
 */
'use client';

import { CommentUIType, VoteValue } from '@/lib/schemas/commentSchemas';
import { Comment } from './Comment';

interface CommentListProps {
  comments: CommentUIType[];
  replyingTo: number | null;
  editingId: number | null;
  userId: string | null;
  actions: {
    createComment: (content: string, parentId: number | null) => Promise<void>;
    updateComment: (id: number, content: string) => Promise<void>;
    deleteComment: (id: number) => Promise<void>;
    vote: (id: number, value: VoteValue) => Promise<void>;
    toggleCollapse: (id: number) => void;
    setReplyingTo: (id: number | null) => void;
    setEditing: (id: number | null) => void;
  };
}

export function CommentList({
  comments,
  replyingTo,
  editingId,
  userId,
  actions,
}: CommentListProps) {
  if (comments.length === 0) {
    return null;
  }

  return (
    <div className="comment-list space-y-4" data-testid="comment-list">
      {comments.map((comment) => (
        <Comment
          key={comment.id}
          comment={comment}
          replyingTo={replyingTo}
          editingId={editingId}
          userId={userId}
          actions={actions}
        />
      ))}
    </div>
  );
}
```

**Implementation - CommentActions.tsx:**
```tsx
/**
 * CommentActions - Action buttons for reply, edit, delete, and collapse.
 * Renders contextual actions based on user permissions.
 */
'use client';

interface CommentActionsProps {
  canReply: boolean;
  canEdit: boolean;
  canDelete: boolean;
  isCollapsed: boolean;
  replyCount: number;
  onReply: () => void;
  onEdit: () => void;
  onDelete: () => void;
  onToggleCollapse: () => void;
}

export function CommentActions({
  canReply,
  canEdit,
  canDelete,
  isCollapsed,
  replyCount,
  onReply,
  onEdit,
  onDelete,
  onToggleCollapse,
}: CommentActionsProps) {
  return (
    <div className="comment-actions flex gap-3 text-sm text-gray-500" data-testid="comment-actions">
      {canReply && (
        <button
          onClick={onReply}
          className="hover:text-gray-700"
          data-testid="reply-btn"
        >
          Reply
        </button>
      )}

      {canEdit && (
        <button
          onClick={onEdit}
          className="hover:text-gray-700"
          data-testid="edit-btn"
        >
          Edit
        </button>
      )}

      {canDelete && (
        <button
          onClick={onDelete}
          className="hover:text-red-500"
          data-testid="delete-btn"
        >
          Delete
        </button>
      )}

      {replyCount > 0 && (
        <button
          onClick={onToggleCollapse}
          className="hover:text-gray-700"
          data-testid="collapse-btn"
        >
          {isCollapsed ? `[+] ${replyCount} replies` : '[-] Collapse'}
        </button>
      )}
    </div>
  );
}
```

**Implementation - CommentForm.tsx:**
```tsx
/**
 * CommentForm - Textarea with submit for new comments and edits.
 * Handles character limit and empty validation.
 */
'use client';

import { useState, useRef, useEffect } from 'react';

interface CommentFormProps {
  initialValue?: string;
  placeholder?: string;
  onSubmit: (content: string) => void | Promise<void>;
  onCancel?: () => void;
  autoFocus?: boolean;
}

export function CommentForm({
  initialValue = '',
  placeholder = 'Write a comment...',
  onSubmit,
  onCancel,
  autoFocus,
}: CommentFormProps) {
  const [content, setContent] = useState(initialValue);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const textareaRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    if (autoFocus && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [autoFocus]);

  const handleSubmit = async () => {
    if (!content.trim() || isSubmitting) return;
    setIsSubmitting(true);
    try {
      await onSubmit(content.trim());
      setContent('');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <div className="comment-form mb-4" data-testid="comment-form">
      <textarea
        ref={textareaRef}
        value={content}
        onChange={(e) => setContent(e.target.value.slice(0, 10000))}
        placeholder={placeholder}
        className="w-full border rounded p-2 min-h-[80px]"
        data-testid="comment-textarea"
      />
      <div className="flex justify-between items-center mt-2">
        <span className="text-sm text-gray-500">{content.length}/10000</span>
        <div className="flex gap-2">
          {onCancel && (
            <button
              onClick={onCancel}
              className="px-3 py-1 text-gray-600 hover:bg-gray-100 rounded"
            >
              Cancel
            </button>
          )}
          <button
            onClick={handleSubmit}
            disabled={!content.trim() || isSubmitting}
            className="px-3 py-1 bg-blue-500 text-white rounded disabled:opacity-50"
            data-testid="comment-submit"
          >
            {isSubmitting ? 'Posting...' : 'Post'}
          </button>
        </div>
      </div>
    </div>
  );
}
```

**Integration point:**
Add `<CommentsSection>` to `src/app/results/page.tsx`:
```tsx
import { CommentsSection } from '@/components/comments/CommentsSection';

// Inside the results page component, after explanation content:
<CommentsSection
  explanationId={explanation.id}
  userId={session?.user?.id ?? null}
/>
```

**Verification:**
1. `npm run type-check` passes
2. Manual testing on localhost: create, reply, vote, edit, delete
3. Component tests pass: `npm test -- Comment`

---

### Phase 7: Testing
**Files to create:**
- `src/lib/services/comments.test.ts`
- `src/lib/services/commentVotes.test.ts`
- `src/reducers/commentsReducer.test.ts`
- `src/__tests__/integration/comments.integration.test.ts`
- `src/__tests__/e2e/specs/07-comments/*.spec.ts`
- `src/__tests__/e2e/helpers/pages/CommentsPage.ts`

**Verification commands:**
```bash
# Unit tests (service layer, reducer)
npm test -- comments.test
npm test -- commentVotes.test
npm test -- commentsReducer.test

# Integration tests (database operations with real Supabase)
npm run test:integration -- comments.integration

# E2E tests (full user flows)
npx playwright test src/__tests__/e2e/specs/07-comments/

# Type check
npm run type-check

# Full test suite
npm test && npm run test:integration && npx playwright test
```

**Verification:** All test suites pass (exit code 0)

---

### Phase 8: Documentation
**Files to update:**
- `docs/docs_overall/architecture.md` - Add comments to Feature Systems
- `docs/feature_deep_dives/comments.md` (new) - Full documentation

**Verification:** Docs reviewed

## 5. Testing

### Test Fixtures
**Files to create:**
- `src/testing/fixtures/commentFixtures.ts`

**Pattern (from src/testing/):**
```typescript
/**
 * Test fixtures for comments system.
 * Provides mock data factories for unit and integration tests.
 */

import { CommentFullDbType, CommentUIType, VoteValue } from '@/lib/schemas/commentSchemas';

export const createMockComment = (overrides: Partial<CommentFullDbType> = {}): CommentFullDbType => ({
  id: 1,
  explanation_id: 1,
  parent_id: null,
  author_id: 'test-user-id',
  path: '1',
  depth: 0,
  content: 'Test comment content',
  upvotes: 0,
  downvotes: 0,
  net_score: 0,
  is_deleted: false,
  is_edited: false,
  created_at: new Date().toISOString(),
  updated_at: new Date().toISOString(),
  ...overrides,
});

export const createMockCommentUI = (overrides: Partial<CommentUIType> = {}): CommentUIType => ({
  ...createMockComment(),
  user_vote: null,
  replies: [],
  is_collapsed: false,
  ...overrides,
});

export const TEST_COMMENT_PREFIX = '__test_comment_';
```

### Unit Tests
| File | Coverage |
|------|----------|
| `src/lib/services/comments.test.ts` | createComment, getCommentsForExplanation, updateComment, deleteComment, buildCommentTree |
| `src/lib/services/commentVotes.test.ts` | castVote (insert/update/toggle), getUserVotesForComments |
| `src/reducers/commentsReducer.test.ts` | All reducer actions, tree manipulation helpers |

**Unit test implementation - comments.test.ts:**
```typescript
// src/lib/services/comments.test.ts
import { createComment, updateComment, deleteComment, buildCommentTree } from './comments';
import { createSupabaseServerClient } from '@/lib/utils/supabase/server';
import { createMockComment, createMockCommentUI } from '@/testing/fixtures/commentFixtures';

jest.mock('@/lib/utils/supabase/server', () => ({
  createSupabaseServerClient: jest.fn()
}));

describe('Comments Service', () => {
  let mockSupabase: any;
  let mockFrom: jest.Mock;
  let mockInsert: jest.Mock;
  let mockSelect: jest.Mock;
  let mockSingle: jest.Mock;

  beforeEach(() => {
    jest.clearAllMocks();
    mockSingle = jest.fn();
    mockSelect = jest.fn(() => ({ single: mockSingle }));
    mockInsert = jest.fn(() => ({ select: mockSelect }));
    mockFrom = jest.fn(() => ({ insert: mockInsert }));
    mockSupabase = { from: mockFrom };
    (createSupabaseServerClient as jest.Mock).mockResolvedValue(mockSupabase);
  });

  describe('createComment', () => {
    it('should create top-level comment and return full record', async () => {
      const mockCreatedComment = createMockComment({ id: 123, content: 'New comment' });
      mockSingle.mockResolvedValue({ data: mockCreatedComment, error: null });

      const result = await createComment(
        { explanation_id: 1, parent_id: null, content: 'New comment' },
        'user-uuid-123'
      );

      expect(result).toEqual(mockCreatedComment);
      expect(mockInsert).toHaveBeenCalledWith(expect.objectContaining({
        explanation_id: 1,
        parent_id: null,
        content: 'New comment',
        author_id: 'user-uuid-123',
      }));
    });

    it('should reject comment if parent depth >= 10', async () => {
      const mockEq = jest.fn(() => ({ single: jest.fn().mockResolvedValue({ data: { depth: 10 }, error: null }) }));
      mockFrom.mockReturnValueOnce({ select: jest.fn(() => ({ eq: mockEq })) });

      await expect(
        createComment({ explanation_id: 1, parent_id: 999, content: 'Too deep' }, 'user-uuid')
      ).rejects.toThrow('Maximum nesting depth (10) exceeded');
    });

    it('should throw on missing userId', async () => {
      await expect(
        createComment({ explanation_id: 1, parent_id: null, content: 'Test' }, '')
      ).rejects.toThrow();
    });
  });

  describe('buildCommentTree', () => {
    it('should build nested tree from flat array', () => {
      const flatComments = [
        createMockComment({ id: 1, parent_id: null, path: '1', depth: 0 }),
        createMockComment({ id: 2, parent_id: 1, path: '1.2', depth: 1 }),
        createMockComment({ id: 3, parent_id: 1, path: '1.3', depth: 1 }),
        createMockComment({ id: 4, parent_id: 2, path: '1.2.4', depth: 2 }),
      ];
      const userVotes = new Map<number, -1 | 1>();

      const tree = buildCommentTree(flatComments, userVotes, 'new');

      expect(tree).toHaveLength(1);
      expect(tree[0].id).toBe(1);
      expect(tree[0].replies).toHaveLength(2);
      expect(tree[0].replies[0].replies).toHaveLength(1);
    });

    it('should sort by top score descending', () => {
      const flatComments = [
        createMockComment({ id: 1, parent_id: null, net_score: 5 }),
        createMockComment({ id: 2, parent_id: null, net_score: 20 }),
        createMockComment({ id: 3, parent_id: null, net_score: 10 }),
      ];

      const tree = buildCommentTree(flatComments, new Map(), 'top');

      expect(tree.map(c => c.id)).toEqual([2, 3, 1]);
    });
  });

  describe('updateComment', () => {
    it('should update content and set is_edited flag', async () => {
      const mockUpdate = jest.fn(() => ({
        eq: jest.fn(() => ({
          eq: jest.fn(() => ({
            select: jest.fn(() => ({
              single: jest.fn().mockResolvedValue({
                data: createMockComment({ content: 'Updated', is_edited: true }),
                error: null
              })
            }))
          }))
        }))
      }));
      mockFrom.mockReturnValue({ update: mockUpdate });

      const result = await updateComment(1, 'user-uuid', 'Updated');

      expect(result.content).toBe('Updated');
      expect(result.is_edited).toBe(true);
    });
  });

  describe('deleteComment', () => {
    it('should soft delete by setting is_deleted and clearing content', async () => {
      const mockUpdate = jest.fn(() => ({
        eq: jest.fn(() => ({
          eq: jest.fn().mockResolvedValue({ error: null })
        }))
      }));
      mockFrom.mockReturnValue({ update: mockUpdate });

      await deleteComment(1, 'user-uuid');

      expect(mockUpdate).toHaveBeenCalledWith({ is_deleted: true, content: '[deleted]' });
    });
  });
});
```

**Unit test implementation - commentsReducer.test.ts:**
```typescript
// src/reducers/commentsReducer.test.ts
import { commentsReducer, createInitialState, CommentsAction } from './commentsReducer';
import { createMockCommentUI } from '@/testing/fixtures/commentFixtures';

describe('commentsReducer', () => {
  describe('LOAD_COMMENTS', () => {
    it('should load comments and clear loading state', () => {
      const state = { ...createInitialState(), isLoading: true };
      const comments = [createMockCommentUI({ id: 1 }), createMockCommentUI({ id: 2 })];

      const result = commentsReducer(state, { type: 'LOAD_COMMENTS', payload: comments });

      expect(result.comments).toEqual(comments);
      expect(result.isLoading).toBe(false);
      expect(result.error).toBeNull();
    });
  });

  describe('TOGGLE_COLLAPSE', () => {
    it('should toggle is_collapsed for target comment', () => {
      const state = {
        ...createInitialState(),
        comments: [createMockCommentUI({ id: 1, is_collapsed: false })],
      };

      const result = commentsReducer(state, { type: 'TOGGLE_COLLAPSE', payload: 1 });

      expect(result.comments[0].is_collapsed).toBe(true);
    });

    it('should toggle nested comment collapse', () => {
      const state = {
        ...createInitialState(),
        comments: [
          createMockCommentUI({
            id: 1,
            replies: [createMockCommentUI({ id: 2, is_collapsed: false })],
          }),
        ],
      };

      const result = commentsReducer(state, { type: 'TOGGLE_COLLAPSE', payload: 2 });

      expect(result.comments[0].replies[0].is_collapsed).toBe(true);
    });
  });

  describe('UPDATE_VOTE', () => {
    it('should update vote from null to upvote', () => {
      const state = {
        ...createInitialState(),
        comments: [createMockCommentUI({ id: 1, user_vote: null, upvotes: 5, net_score: 5 })],
      };

      const result = commentsReducer(state, {
        type: 'UPDATE_VOTE',
        payload: { id: 1, vote: 1, scoreDelta: 1 },
      });

      expect(result.comments[0].user_vote).toBe(1);
      expect(result.comments[0].upvotes).toBe(6);
      expect(result.comments[0].net_score).toBe(6);
    });

    it('should handle vote change from upvote to downvote', () => {
      const state = {
        ...createInitialState(),
        comments: [createMockCommentUI({ id: 1, user_vote: 1, upvotes: 5, downvotes: 2, net_score: 3 })],
      };

      const result = commentsReducer(state, {
        type: 'UPDATE_VOTE',
        payload: { id: 1, vote: -1, scoreDelta: -2 },
      });

      expect(result.comments[0].user_vote).toBe(-1);
      expect(result.comments[0].upvotes).toBe(4);
      expect(result.comments[0].downvotes).toBe(3);
      expect(result.comments[0].net_score).toBe(1);
    });
  });

  describe('ADD_COMMENT', () => {
    it('should prepend top-level comment', () => {
      const state = {
        ...createInitialState(),
        comments: [createMockCommentUI({ id: 1 })],
      };
      const newComment = createMockCommentUI({ id: 2 });

      const result = commentsReducer(state, {
        type: 'ADD_COMMENT',
        payload: { comment: newComment, parentId: null },
      });

      expect(result.comments[0].id).toBe(2);
      expect(result.comments).toHaveLength(2);
    });

    it('should add reply to parent comment', () => {
      const state = {
        ...createInitialState(),
        comments: [createMockCommentUI({ id: 1, replies: [] })],
        replyingTo: 1,
      };
      const reply = createMockCommentUI({ id: 2 });

      const result = commentsReducer(state, {
        type: 'ADD_COMMENT',
        payload: { comment: reply, parentId: 1 },
      });

      expect(result.comments[0].replies[0].id).toBe(2);
      expect(result.replyingTo).toBeNull();
    });
  });
});
```

### Integration Tests
| File | Coverage |
|------|----------|
| `src/__tests__/integration/comments.integration.test.ts` | Full CRUD flow, voting persistence, RLS enforcement |

**Integration test pattern:**
```typescript
// Uses real Supabase with service role key
describe('Comments Integration Tests', () => {
  let supabase: SupabaseClient;
  let testExplanationId: number;
  let cleanup: () => Promise<void>;

  beforeAll(async () => {
    supabase = await setupTestDatabase();
    // Create test explanation for comments
    testExplanationId = await createTestExplanation(supabase);
  });

  afterAll(async () => {
    // Cleanup test comments by prefix
    await supabase.from('comments').delete().like('content', `${TEST_COMMENT_PREFIX}%`);
    await teardownTestDatabase(supabase);
  });

  describe('RLS Enforcement', () => {
    it('should prevent user from updating another user comment', async () => {
      // Create comment as user A
      const userAId = 'user-a-uuid';
      const { data: comment } = await supabase.from('comments').insert({
        explanation_id: testExplanationId,
        author_id: userAId,
        content: `${TEST_COMMENT_PREFIX}User A comment`,
      }).select().single();

      // Try to update as user B (simulated via RLS context)
      const userBClient = await createUserClient('user-b-uuid');
      const { error } = await userBClient.from('comments')
        .update({ content: 'Hacked!' })
        .eq('id', comment.id);

      expect(error).toBeDefined();
    });
  });

  describe('Vote Triggers', () => {
    it('should increment upvotes when vote is inserted', async () => {
      const { data: comment } = await supabase.from('comments').insert({
        explanation_id: testExplanationId,
        author_id: 'test-author',
        content: `${TEST_COMMENT_PREFIX}Vote test`,
      }).select().single();

      await supabase.from('comment_votes').insert({
        comment_id: comment.id,
        user_id: 'voter-uuid',
        vote_value: 1,
      });

      const { data: updated } = await supabase.from('comments')
        .select('upvotes, net_score')
        .eq('id', comment.id)
        .single();

      expect(updated.upvotes).toBe(1);
      expect(updated.net_score).toBe(1);
    });
  });

  describe('Path Trigger', () => {
    it('should set path for top-level comment', async () => {
      const { data: comment } = await supabase.from('comments').insert({
        explanation_id: testExplanationId,
        author_id: 'test-author',
        content: `${TEST_COMMENT_PREFIX}Path test`,
      }).select().single();

      expect(comment.path).toBe(comment.id.toString());
      expect(comment.depth).toBe(0);
    });

    it('should set nested path for reply', async () => {
      const { data: parent } = await supabase.from('comments').insert({
        explanation_id: testExplanationId,
        author_id: 'test-author',
        content: `${TEST_COMMENT_PREFIX}Parent`,
      }).select().single();

      const { data: reply } = await supabase.from('comments').insert({
        explanation_id: testExplanationId,
        parent_id: parent.id,
        author_id: 'test-author',
        content: `${TEST_COMMENT_PREFIX}Reply`,
      }).select().single();

      expect(reply.path).toBe(`${parent.id}.${reply.id}`);
      expect(reply.depth).toBe(1);
    });
  });
});
```

### E2E Tests
| File | Coverage |
|------|----------|
| `src/__tests__/e2e/specs/07-comments/comment-crud.spec.ts` | Create, read, edit, delete comments |
| `src/__tests__/e2e/specs/07-comments/comment-voting.spec.ts` | Upvote, downvote, toggle, score display |
| `src/__tests__/e2e/specs/07-comments/comment-threading.spec.ts` | Reply chains, collapse/expand, depth limit |

**Page Object:**
```typescript
// src/__tests__/e2e/helpers/pages/CommentsPage.ts
import { Page, Locator } from '@playwright/test';
import { BasePage } from './BasePage';

export class CommentsPage extends BasePage {
  readonly commentInput: Locator;
  readonly submitButton: Locator;
  readonly sortDropdown: Locator;

  constructor(page: Page) {
    super(page);
    this.commentInput = page.getByTestId('comment-input');
    this.submitButton = page.getByTestId('comment-submit');
    this.sortDropdown = page.getByTestId('comment-sort');
  }

  async createComment(content: string) {
    await this.commentInput.fill(content);
    await this.submitButton.click();
    await this.page.waitForSelector(`text=${content}`);
  }

  async upvote(commentId: number) {
    await this.page.getByTestId(`upvote-${commentId}`).click();
  }
}
```

## 6. CI/CD Integration

### Workflow Changes
**File:** `.github/workflows/ci.yml`

**No changes required** - existing workflow structure handles new tests:
- Unit tests: `npm test` already runs all `.test.ts` files
- Integration tests: `npm run test:integration` already runs `__tests__/integration/`
- E2E tests: `npx playwright test` already runs `__tests__/e2e/specs/`

**Verification:**
1. Confirm `07-comments/` specs are discovered by Playwright
2. Confirm integration test cleanup doesn't affect other tests

### Environment Variables
**No new env vars required** - uses existing Supabase credentials.

## 7. Rollback Plan

### Database Rollback
If critical bugs are discovered post-deployment:

```sql
-- Step 1: Disable triggers (prevent cascading issues)
DROP TRIGGER IF EXISTS trigger_update_comment_votes ON public.comment_votes;
DROP TRIGGER IF EXISTS trigger_set_comment_path ON public.comments;
DROP TRIGGER IF EXISTS trigger_comments_updated_at ON public.comments;

-- Step 2: Drop tables (cascades to votes via FK)
DROP TABLE IF EXISTS public.comment_votes CASCADE;
DROP TABLE IF EXISTS public.comments CASCADE;

-- Step 3: Drop functions
DROP FUNCTION IF EXISTS public.update_comment_vote_counts();
DROP FUNCTION IF EXISTS public.set_comment_path();
DROP FUNCTION IF EXISTS public.update_comments_updated_at();
DROP FUNCTION IF EXISTS public.calculate_comment_depth();
```

### Code Rollback
1. Revert git commits for phases 2-6
2. Remove component integration from `results/page.tsx`
3. Deploy reverted code

### Partial Rollback (Disable Feature)
If issues are minor, can hide UI without DB rollback:
1. Add feature flag: `NEXT_PUBLIC_COMMENTS_ENABLED=false`
2. Wrap `<CommentsSection>` in conditional render
3. Keep data for later re-enablement

## 8. Dependencies

### Required Packages
Before implementation, verify these packages are installed:

```bash
# Check if dependencies exist, install if missing
npm ls date-fns || npm install date-fns
npm ls lucide-react || npm install lucide-react
```

| Package | Purpose | Verification |
|---------|---------|--------------|
| `date-fns` | `formatDistanceToNow` for relative timestamps | `npm ls date-fns` |
| `lucide-react` | `ChevronUp`, `ChevronDown` icons for voting | `npm ls lucide-react` |
| `zod` | Already in codebase | Schema validation |

### Existing Dependencies Used
- `react` - Component framework (already installed)
- `@supabase/supabase-js` - Database client (already installed)
- `@/lib/utils` - `cn()` utility for className merging (already in codebase)

## 9. Security Considerations

### XSS Prevention
Comment content is user-generated and must be treated as untrusted:

1. **Database layer**: Content stored as plain text (no HTML allowed)
2. **Display layer**: React's default escaping handles XSS prevention
   - Use `{comment.content}` in JSX (auto-escaped)
   - NEVER use `dangerouslySetInnerHTML` with comment content
3. **Markdown support** (if added later): Use sanitized markdown renderer like `react-markdown` with no HTML passthrough

**Implementation pattern in Comment.tsx:**
```tsx
// SAFE - React auto-escapes
<p className="comment-content">{comment.content}</p>

// DANGEROUS - Never do this with user content
// <div dangerouslySetInnerHTML={{ __html: comment.content }} />
```

### Content Validation
- **Max length**: 10,000 chars enforced at DB level via CHECK constraint
- **Min length**: 1 char enforced via Zod schema
- **No HTML tags**: Stored as plain text, displayed with React escaping

### CSRF Protection
Next.js Server Actions have built-in CSRF protection:
- Server Actions are POST-only endpoints that require proper origin headers
- Next.js automatically validates the `Origin` header against allowed hosts
- The `'use server'` directive creates secure server-only functions
- No additional CSRF token management required

**Reference**: https://nextjs.org/blog/security-nextjs-server-components-actions

### Rate Limiting
Rate limiting handled at API gateway level (existing Vercel/Supabase limits apply).
For future enhancement: Add application-level rate limiting if abuse detected.

### SQL Injection Prevention
- All database queries use Supabase client with parameterized queries
- No raw SQL string concatenation in service layer
- Path queries use proper `LIKE` escaping via Supabase query builder
- Trigger functions use parameterized `$1`, `$2` style (not string interpolation)

## 9. Documentation Updates

| File | Updates |
|------|---------|
| `docs/docs_overall/architecture.md` | Add Comments System to Feature Systems section |
| `docs/feature_deep_dives/comments.md` | New file: schema, API, component docs |
